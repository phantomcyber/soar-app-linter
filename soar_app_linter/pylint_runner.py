"""Pylint runner for SOAR apps."""

import logging
import os
from importlib import resources as importlib_resources
import subprocess
import sys
from enum import Enum
from pathlib import Path
from typing import List, Union
import re
import json

logger = logging.getLogger(__name__)


class MessageLevel(str, Enum):
    """Message severity levels."""

    ERROR = "error"
    INFO = "info"

    def to_pylint_disable(self) -> List[str]:
        """Convert to pylint's disable arguments."""
        if self == MessageLevel.ERROR:
            return ["--disable=all", "--enable=F,E"]
        return []  # info or no option provided will show everything


# Treat E0401 import errors for these modules as non-fatal platform deps.
# These names correspond to import-time module names (not strictly PyPI names).
ALLOWED_E0401_IMPORT_NAMES = {
    # Core/platform packages
    "beautifulsoup4",
    "bs4",
    "soupsieve",
    "parse",
    "python_dateutil",
    "dateutil",
    "six",
    "requests",
    "certifi",
    "charset_normalizer",
    "idna",
    "urllib3",
    "sh",
    "xmltodict",
    "simplejson",
    "python-dateutil",
    "python-magic",
    "magic",
    "distro",
    "django",
    "requests-pkcs12",
    "requests_pkcs12",
    "pynacl",
    "nacl",
    "psycopg2",
    "PyYAML",
    "yaml",
    "hvac",
    "pylint",
    "pudb",
    "tabulate",
    "markdown2",
    "pytz",
    # XML/HTML helpers
    "lxml",
    "defusedxml",
    "html5lib",
    "webencodings",
    # Platform/phantom helpers
    "phantom_common",
    "encryption_helper",
    # Extras from provided dependency list
    "zeep",
    "paramiko",
    "boto3",
    # Azure SDKs
    "azure",
    "azure.core",
    "azure.identity",
    "azure.keyvault.secrets",
    "azure.keyvault.keys",
    "azure.mgmt.compute",
    "azure.mgmt.rdbms",
    # Google SDKs
    "google.cloud.secretmanager",
    "google_crc32c",
}


def _find_python_files(
    directory: Union[str, Path], use_relative_paths: bool = False
) -> List[str]:
    """Find all Python files in the given directory."""
    logger.debug(f"Searching for Python files in: {directory}")

    if isinstance(directory, str):
        directory = Path(directory)

    if not directory.exists():
        logger.error(f"Directory does not exist: {directory}")
        return []

    if not directory.is_dir():
        logger.error(f"Path is not a directory: {directory}")
        return []

    files = []
    for path in directory.rglob("*.py"):
        # Skip files in .venv
        if any(part == ".venv" for part in path.parts):
            continue
        if path.is_file() and not path.name.startswith("."):
            logger.debug(f"Found Python file: {path}")
            if use_relative_paths:
                # Use path relative to the directory for local imports to work correctly
                relative_path = path.relative_to(directory)
                files.append(str(relative_path))
            else:
                files.append(str(path.absolute()))

    logger.debug(f"Found {len(files)} Python files in {directory} (excluding .venv)")
    return files


def _ensure_init_files(directory: str) -> None:
    """Ensure all Python packages have __init__.py files."""
    logger.debug(f"Ensuring __init__.py files in: {directory}")
    init_created = 0

    for root, dirs, _ in os.walk(directory):
        # Skip hidden directories and __pycache__
        dirs[:] = [d for d in dirs if not d.startswith(".") and d != "__pycache__"]

        # Skip if this is a Python package with an __init__.py
        init_path = os.path.join(root, "__init__.py")
        if os.path.isfile(init_path):
            continue

        # Check if this is a Python package (has .py files or is imported)
        has_py_files = any(fname.endswith(".py") for fname in os.listdir(root))
        is_imported = any(
            os.path.isfile(os.path.join(root, f"{d}.py"))
            for d in os.listdir(
                os.path.dirname(root) if os.path.dirname(root) != root else root
            )
            if os.path.isdir(
                os.path.join(
                    os.path.dirname(root) if os.path.dirname(root) != root else root, d
                )
            )
        )

        if has_py_files or is_imported:
            # Create empty __init__.py
            with open(init_path, "w", encoding="utf-8") as f:
                f.write("# Automatically generated by pylint-runner\n")
            logger.debug(f"Created {init_path}")
            init_created += 1

    if init_created > 0:
        logger.debug(f"Created {init_created} __init__.py files")
    else:
        logger.debug("No new __init__.py files were needed")


def _has_errors_in_output(output: str, output_format: str) -> bool:
    """Check if there are any errors in the pylint output.

    Treat E0401 import errors involving modules listed in
    ALLOWED_E0401_IMPORT_NAMES as non-fatal (ignored for exit status).
    """

    def _is_allowed_import_error(message_text: str) -> bool:
        text_lower = message_text.lower()
        for pkg in ALLOWED_E0401_IMPORT_NAMES:
            pkg_lower = pkg.lower()
            if (
                f"'{pkg_lower}'" in text_lower
                or f'"{pkg_lower}"' in text_lower
                or f"'{pkg_lower}." in text_lower
                or f'"{pkg_lower}.' in text_lower
                or f" {pkg_lower} " in text_lower
                or f" {pkg_lower}." in text_lower
                or text_lower.endswith(f" {pkg_lower}")
                or text_lower.startswith(f"{pkg_lower} ")
                or text_lower.startswith(f"{pkg_lower}.")
            ):
                return True
        return False

    if output_format == "json":
        try:
            results = json.loads(output)
            for result in results:
                msg_type = result.get("type")
                if msg_type not in ("error", "fatal"):
                    continue
                msg_id = result.get("message-id")
                if msg_id == "E0401" and _is_allowed_import_error(
                    result.get("message", "")
                ):
                    continue
                return True
            return False
        except json.JSONDecodeError:
            raise
    else:
        error_line_re = re.compile(r":\s([EF])\d{4}:\s*(.+)$")
        for line in output.splitlines():
            match = error_line_re.search(line)
            if not match:
                continue
            code_type = match.group(1)
            message_text = match.group(2)
            if "E0401:" in line and _is_allowed_import_error(message_text):
                continue
            if code_type in ("E", "F"):
                return True
        return False


def run_pylint(
    target: str,
    output_format: str = "text",
    verbose: bool = False,
    message_level: MessageLevel = MessageLevel.INFO,
    no_deps: bool = False,
) -> tuple[int, str]:
    """Run pylint on the target directory or file.

    Args:
        target: The target directory or file to lint
        output_format: Output format ('text' or 'json')
        verbose: Enable verbose output
        message_level: Minimum message level to show
        no_deps: If True, skip dependency installation and ignore import errors

    Returns:
        tuple: (exit_code, output)
    """
    if verbose:
        logger.setLevel(logging.DEBUG)

    logger.debug(f"Running pylint on target: {target}")

    # Use the repo's .venv/bin/python if it exists, else fall back to sys.executable
    venv_python = None
    target_path = Path(target).resolve()
    repo_root = target_path if target_path.is_dir() else target_path.parent
    venv_candidate = repo_root / ".venv" / "bin" / "python"
    venv_site_packages = None

    if venv_candidate.exists():
        venv_python = str(venv_candidate)
        logger.debug(f"Using venv python: {venv_python}")

        # Find the site-packages directory in the venv
        venv_site_packages = (
            repo_root / ".venv" / "lib" / "python3.13" / "site-packages"
        )
        if not venv_site_packages.exists():
            # Try to find the correct Python version directory
            lib_dir = repo_root / ".venv" / "lib"
            if lib_dir.exists():
                python_dirs = [
                    d for d in lib_dir.iterdir() if d.name.startswith("python3.")
                ]
                if python_dirs:
                    venv_site_packages = python_dirs[0] / "site-packages"

        if venv_site_packages and venv_site_packages.exists():
            logger.debug(f"Found venv site-packages at: {venv_site_packages}")
        else:
            logger.warning(
                f"Could not find site-packages in venv at {repo_root / '.venv'}"
            )
            venv_site_packages = None
    else:
        venv_python = sys.executable
        logger.warning(
            f"No .venv found at {venv_candidate}. Using system Python: {venv_python}. "
            "This may cause import errors. To avoid this, ensure dependencies are installed in a per-repo .venv."
        )

    # Resolve rcfile path robustly whether running from source or installed package
    try:
        rcfile_path = importlib_resources.files(__package__).joinpath("pylintrc.app")
        rcfile_str = str(rcfile_path)
    except Exception:
        rcfile_str = os.path.join(os.path.dirname(__file__), "pylintrc.app")

    if not os.path.exists(rcfile_str):
        logger.error(
            f"Missing pylintrc at {rcfile_str}. Ensure 'pylintrc.app' is packaged with soar_app_linter."
        )
        return 1, ""

    # Ensure that the child pylint process can import our plugins even if it
    # runs in a different interpreter (e.g. repo .venv vs pre-commit env).
    # We inject the parent directory of the installed 'soar_app_linter' package
    # (the site-packages path that contains the package) into sys.path.
    try:
        installed_pkg_parent = (
            Path(__file__).resolve().parent  # .../soar_app_linter
        ).parent  # site-packages or project root containing soar_app_linter
        init_hook = (
            "import sys; "
            "sys.path.insert(0, '.'); "
            f"sys.path.insert(0, '{installed_pkg_parent.as_posix()}')"
        )
    except Exception:
        # Fallback to the original minimal init hook
        init_hook = "import sys; sys.path.insert(0, '.')"

    cmd = [
        venv_python,
        "-m",
        "pylint",
        f"--rcfile={rcfile_str}",
        "--load-plugins=soar_app_linter.plugins",
        f"--init-hook={init_hook}",
    ]

    # Instruct pylint to ignore import checks for allowed modules at source so
    # they do not contribute to score or raw output.
    try:
        ignored_modules = sorted(
            {name.split(".")[0] for name in ALLOWED_E0401_IMPORT_NAMES}
        )
        if ignored_modules:
            cmd.append(f"--ignored-modules={','.join(ignored_modules)}")
    except Exception:
        # Fallback: skip adding ignored modules if computation fails
        pass

    # Add message level filtering first
    disable = message_level.to_pylint_disable()
    if disable:
        cmd.extend(disable)

    # Ignore import errors when no_deps is True
    if no_deps:
        cmd.extend(["--disable=import-error"])

    # Add additional ignore patterns for known-good modules that have import issues due to namespace conflicts
    # This must come AFTER message level filtering to override --disable=all --enable=F,E
    target_basename = os.path.basename(target)
    if target_basename in [
        "databricks",
        "splunk",
        "aws",
        "azure",
        "google",
        "git",
        "dns",
        "jira",
    ]:
        # These are common namespace conflicts - disable specific import errors
        cmd.extend(
            [
                "--disable=import-error",
            ]
        )
        logger.debug(
            f"Disabling import-error for namespace conflict repo: {target_basename}"
        )

    # Disable error codes that are inconsistent between tool and platform behavior
    # These errors are often false positives in SOAR app environments due to dynamic nature
    cmd.extend(
        [
            "--disable=no-member",  # E1101
            "--disable=no-name-in-module",  # E0611
            "--disable=unsupported-membership-test",  # E1135
            "--disable=unsupported-assignment-operation",  # E1137
            "--disable=unsubscriptable-object",  # E1136
        ]
    )
    logger.debug("Disabling problematic error codes: E1101, E0611, E1135, E1137, E1136")

    if output_format == "json":
        cmd.append("--output-format=json")

    if os.path.isdir(target):
        _ensure_init_files(target)
        # Set the working directory to the target directory for relative imports
        working_dir = target
        logger.debug(f"Setting working directory to: {working_dir}")
        # Use relative paths when we set the working directory
        files = _find_python_files(target, use_relative_paths=True)
        if not files:
            logger.warning(f"No Python files found in {target}")
            return 0, ""
        cmd.extend(files)
    else:
        if not os.path.exists(target):
            logger.error(f"Target file does not exist: {target}")
            return 1, f"Error: Target file does not exist: {target}"
        # For single files, don't set working directory and use absolute path
        working_dir = None
        cmd.append(target)

    logger.debug(f"Running command: {' '.join(cmd)}")

    try:
        result = subprocess.run(
            cmd,
            capture_output=True,
            text=True,
            check=False,
            cwd=working_dir,
        )

        # Log stderr if present
        if result.stderr:
            logger.error(f"Pylint stderr: {result.stderr}")

        # Check if there were any errors in the output
        has_errors = _has_errors_in_output(result.stdout, output_format)

        # Determine failure based on filtered errors, not raw pylint return code
        # so that allowed E0401 imports do not fail the run even if pylint
        # returned non-zero due to those messages.
        exit_code = 1 if has_errors else 0
        return exit_code, result.stdout

    except subprocess.CalledProcessError as e:
        logger.error(f"Error running pylint: {e!s}")
        return 1, e.output or str(e)
