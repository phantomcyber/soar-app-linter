"""Pylint runner for SOAR apps."""

import logging
import os
import subprocess
import sys
from enum import Enum
from pathlib import Path
from typing import List, Union
import re
import json

logger = logging.getLogger(__name__)


class MessageLevel(str, Enum):
    """Message severity levels."""
    ERROR = "error"
    INFO = "info"

    def to_pylint_disable(self) -> List[str]:
        """Convert to pylint's disable arguments."""
        if self == MessageLevel.ERROR:
            return ["--disable=all", "--enable=F,E"]
        return []  # info or no option provided will show everything

def _find_python_files(directory: Union[str, Path]) -> List[str]:
    """Find all Python files in the given directory."""
    logger.debug(f"Searching for Python files in: {directory}")
    
    if isinstance(directory, str):
        directory = Path(directory)
    
    if not directory.exists():
        logger.error(f"Directory does not exist: {directory}")
        return []

    if not directory.is_dir():
        logger.error(f"Path is not a directory: {directory}")
        return []

    files = []
    for path in directory.rglob("*.py"):
        if path.is_file() and not path.name.startswith('.'):
            logger.debug(f"Found Python file: {path}")
            files.append(str(path.absolute()))

    logger.debug(f"Found {len(files)} Python files in {directory}")
    return files

def _ensure_init_files(directory: str) -> None:
    """Ensure all Python packages have __init__.py files."""
    logger.debug(f"Ensuring __init__.py files in: {directory}")
    init_created = 0

    for root, dirs, _ in os.walk(directory):
        # Skip hidden directories and __pycache__
        dirs[:] = [d for d in dirs if not d.startswith(".") and d != "__pycache__"]

        # Skip if this is a Python package with an __init__.py
        init_path = os.path.join(root, "__init__.py")
        if os.path.isfile(init_path):
            continue

        # Check if this is a Python package (has .py files or is imported)
        has_py_files = any(fname.endswith('.py') for fname in os.listdir(root))
        is_imported = any(
            os.path.isfile(os.path.join(root, f"{d}.py"))
            for d in os.listdir(os.path.dirname(root) if os.path.dirname(root) != root else root)
            if os.path.isdir(os.path.join(os.path.dirname(root) if os.path.dirname(root) != root else root, d))
        )

        if has_py_files or is_imported:
            # Create empty __init__.py
            with open(init_path, 'w', encoding='utf-8') as f:
                f.write("# Automatically generated by pylint-runner\n")
            logger.debug(f"Created {init_path}")
            init_created += 1

    if init_created > 0:
        logger.debug(f"Created {init_created} __init__.py files")
    else:
        logger.debug("No new __init__.py files were needed")


def _has_errors_in_output(output: str, output_format: str) -> bool:
    """Check if there are any errors in the pylint output."""
    if output_format == "json":
        try:
            results = json.loads(output)
            return any(
                result.get("type") in ("error", "fatal")
                for result in results
            )
        except json.JSONDecodeError:
            raise
    else:
        # For text output, look for error indicators
        error_pattern = re.compile(r':\s[EF]\d{4}:')
        return any(
            bool(error_pattern.search(line))
            for line in output.splitlines()
        )


def run_pylint(
    target: str,
    output_format: str = "text",
    verbose: bool = False,
    message_level: MessageLevel = MessageLevel.INFO,
    no_deps: bool = False,
) -> tuple[int, str]:
    """Run pylint on the target directory or file.

    Args:
        target: The target directory or file to lint
        output_format: Output format ('text' or 'json')
        verbose: Enable verbose output
        message_level: Minimum message level to show
        no_deps: If True, skip dependency installation and ignore import errors

    Returns:
        tuple: (exit_code, output)
    """
    if verbose:
        logger.setLevel(logging.DEBUG)

    logger.debug(f"Running pylint on target: {target}")

    # Create a dynamic init-hook that adds the target directory to Python path
    init_hook = (
        'import sys, os; '
        f'sys.path.extend(["{target}"])'
    )

    cmd = [
        sys.executable,
        "-m",
        "pylint",
        f"--rcfile={os.path.join(os.path.dirname(__file__), 'pylintrc.app')}",
        "--load-plugins=soar_app_linter.plugins",
        f"--init-hook={init_hook}",
    ]

    # Add message level filtering
    disable = message_level.to_pylint_disable()
    if disable:
        cmd.extend(disable)

    # Ignore import errors when no_deps is True
    if no_deps:
        cmd.extend(["--disable=import-error"])

    if output_format == "json":
        cmd.append("--output-format=json")

    if os.path.isdir(target):
        _ensure_init_files(target)
        files = _find_python_files(target)
        if not files:
            logger.warning(f"No Python files found in {target}")
            return 0, ""
        cmd.extend(files)
    else:
        if not os.path.exists(target):
            logger.error(f"Target file does not exist: {target}")
            return 1, f"Error: Target file does not exist: {target}"
        cmd.append(target)

    logger.debug(f"Running command: {' '.join(cmd)}")
    try:
        result = subprocess.run(
            cmd,
            capture_output=True,
            text=True,
            check=False,
        )

        # Log stderr if present
        if result.stderr:
            logger.error(f"Pylint stderr: {result.stderr}")

        # Check if there were any errors in the output
        has_errors = _has_errors_in_output(result.stdout, output_format)

        # Return code is 0 only if there were no errors and pylint succeeded
        # https://pylint.pycqa.org/en/latest/user_guide/usage/run.html#exit-codes
        exit_code = 1 if (has_errors or result.returncode in (1,2)) else 0
        return exit_code, result.stdout

    except subprocess.CalledProcessError as e:
        logger.error(f"Error running pylint: {e!s}")
        return 1, e.output or str(e)
