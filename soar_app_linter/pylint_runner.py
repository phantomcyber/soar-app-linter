"""Pylint runner for SOAR apps."""

import logging
import os
from importlib import resources as importlib_resources
import subprocess
import sys
from enum import Enum
from pathlib import Path
from typing import List, Union
import re
import json

logger = logging.getLogger(__name__)


class MessageLevel(str, Enum):
    """Message severity levels."""

    ERROR = "error"
    INFO = "info"

    def to_pylint_disable(self) -> List[str]:
        """Convert to pylint's disable arguments."""
        if self == MessageLevel.ERROR:
            return ["--disable=all", "--enable=F,E"]
        return []  # info or no option provided will show everything


def _find_python_files(
    directory: Union[str, Path], use_relative_paths: bool = False
) -> List[str]:
    """Find all Python files in the given directory."""
    logger.debug(f"Searching for Python files in: {directory}")

    if isinstance(directory, str):
        directory = Path(directory)

    if not directory.exists():
        logger.error(f"Directory does not exist: {directory}")
        return []

    if not directory.is_dir():
        logger.error(f"Path is not a directory: {directory}")
        return []

    files = []
    for path in directory.rglob("*.py"):
        # Skip files in .venv
        if any(part == ".venv" for part in path.parts):
            continue
        if path.is_file() and not path.name.startswith("."):
            logger.debug(f"Found Python file: {path}")
            if use_relative_paths:
                # Use path relative to the directory for local imports to work correctly
                relative_path = path.relative_to(directory)
                files.append(str(relative_path))
            else:
                files.append(str(path.absolute()))

    logger.debug(f"Found {len(files)} Python files in {directory} (excluding .venv)")
    return files


def _ensure_init_files(directory: str) -> None:
    """Ensure all Python packages have __init__.py files."""
    logger.debug(f"Ensuring __init__.py files in: {directory}")
    init_created = 0

    for root, dirs, _ in os.walk(directory):
        # Skip hidden directories and __pycache__
        dirs[:] = [d for d in dirs if not d.startswith(".") and d != "__pycache__"]

        # Skip if this is a Python package with an __init__.py
        init_path = os.path.join(root, "__init__.py")
        if os.path.isfile(init_path):
            continue

        # Check if this is a Python package (has .py files or is imported)
        has_py_files = any(fname.endswith(".py") for fname in os.listdir(root))
        is_imported = any(
            os.path.isfile(os.path.join(root, f"{d}.py"))
            for d in os.listdir(
                os.path.dirname(root) if os.path.dirname(root) != root else root
            )
            if os.path.isdir(
                os.path.join(
                    os.path.dirname(root) if os.path.dirname(root) != root else root, d
                )
            )
        )

        if has_py_files or is_imported:
            # Create empty __init__.py
            with open(init_path, "w", encoding="utf-8") as f:
                f.write("# Automatically generated by pylint-runner\n")
            logger.debug(f"Created {init_path}")
            init_created += 1

    if init_created > 0:
        logger.debug(f"Created {init_created} __init__.py files")
    else:
        logger.debug("No new __init__.py files were needed")


def _has_errors_in_output(output: str, output_format: str) -> bool:
    """Check if there are any errors in the pylint output."""
    if output_format == "json":
        try:
            results = json.loads(output)
            return any(result.get("type") in ("error", "fatal") for result in results)
        except json.JSONDecodeError:
            raise
    else:
        # For text output, look for error indicators
        error_pattern = re.compile(r":\s[EF]\d{4}:")
        return any(bool(error_pattern.search(line)) for line in output.splitlines())


def run_pylint(
    target: str,
    output_format: str = "text",
    verbose: bool = False,
    message_level: MessageLevel = MessageLevel.INFO,
    no_deps: bool = False,
) -> tuple[int, str]:
    """Run pylint on the target directory or file.

    Args:
        target: The target directory or file to lint
        output_format: Output format ('text' or 'json')
        verbose: Enable verbose output
        message_level: Minimum message level to show
        no_deps: If True, skip dependency installation and ignore import errors

    Returns:
        tuple: (exit_code, output)
    """
    if verbose:
        logger.setLevel(logging.DEBUG)

    logger.debug(f"Running pylint on target: {target}")

    # Use the repo's .venv/bin/python if it exists, else fall back to sys.executable
    venv_python = None
    target_path = Path(target).resolve()
    repo_root = target_path if target_path.is_dir() else target_path.parent
    venv_candidate = repo_root / ".venv" / "bin" / "python"
    venv_site_packages = None

    if venv_candidate.exists():
        venv_python = str(venv_candidate)
        logger.debug(f"Using venv python: {venv_python}")

        # Find the site-packages directory in the venv
        venv_site_packages = (
            repo_root / ".venv" / "lib" / "python3.13" / "site-packages"
        )
        if not venv_site_packages.exists():
            # Try to find the correct Python version directory
            lib_dir = repo_root / ".venv" / "lib"
            if lib_dir.exists():
                python_dirs = [
                    d for d in lib_dir.iterdir() if d.name.startswith("python3.")
                ]
                if python_dirs:
                    venv_site_packages = python_dirs[0] / "site-packages"

        if venv_site_packages and venv_site_packages.exists():
            logger.debug(f"Found venv site-packages at: {venv_site_packages}")
        else:
            logger.warning(
                f"Could not find site-packages in venv at {repo_root / '.venv'}"
            )
            venv_site_packages = None
    else:
        venv_python = sys.executable
        logger.warning(
            f"No .venv found at {venv_candidate}. Using system Python: {venv_python}. "
            "This may cause import errors. To avoid this, ensure dependencies are installed in a per-repo .venv."
        )

    # Resolve rcfile path robustly whether running from source or installed package
    try:
        rcfile_path = importlib_resources.files(__package__).joinpath("pylintrc.app")
        rcfile_str = str(rcfile_path)
    except Exception:
        rcfile_str = os.path.join(os.path.dirname(__file__), "pylintrc.app")

    if not os.path.exists(rcfile_str):
        logger.error(
            f"Missing pylintrc at {rcfile_str}. Ensure 'pylintrc.app' is packaged with soar_app_linter."
        )
        return 1, ""

    cmd = [
        venv_python,
        "-m",
        "pylint",
        f"--rcfile={rcfile_str}",
        "--load-plugins=soar_app_linter.plugins",
        "--init-hook=import sys; sys.path.insert(0, '.')",
    ]

    # Add message level filtering first
    disable = message_level.to_pylint_disable()
    if disable:
        cmd.extend(disable)

    # Ignore import errors when no_deps is True
    if no_deps:
        cmd.extend(["--disable=import-error"])

    # Add additional ignore patterns for known-good modules that have import issues due to namespace conflicts
    # This must come AFTER message level filtering to override --disable=all --enable=F,E
    target_basename = os.path.basename(target)
    if target_basename in [
        "databricks",
        "splunk",
        "aws",
        "azure",
        "google",
        "git",
        "dns",
        "jira",
    ]:
        # These are common namespace conflicts - disable specific import errors
        cmd.extend(
            [
                "--disable=import-error",
            ]
        )
        logger.debug(
            f"Disabling import-error for namespace conflict repo: {target_basename}"
        )

    # Disable error codes that are inconsistent between tool and platform behavior
    # These errors are often false positives in SOAR app environments due to dynamic nature
    cmd.extend(
        [
            "--disable=no-member",  # E1101
            "--disable=no-name-in-module",  # E0611
            "--disable=unsupported-membership-test",  # E1135
            "--disable=unsupported-assignment-operation",  # E1137
            "--disable=unsubscriptable-object",  # E1136
        ]
    )
    logger.debug("Disabling problematic error codes: E1101, E0611, E1135, E1137, E1136")

    if output_format == "json":
        cmd.append("--output-format=json")

    if os.path.isdir(target):
        _ensure_init_files(target)
        # Set the working directory to the target directory for relative imports
        working_dir = target
        logger.debug(f"Setting working directory to: {working_dir}")
        # Use relative paths when we set the working directory
        files = _find_python_files(target, use_relative_paths=True)
        if not files:
            logger.warning(f"No Python files found in {target}")
            return 0, ""
        cmd.extend(files)
    else:
        if not os.path.exists(target):
            logger.error(f"Target file does not exist: {target}")
            return 1, f"Error: Target file does not exist: {target}"
        # For single files, don't set working directory and use absolute path
        working_dir = None
        cmd.append(target)

    logger.debug(f"Running command: {' '.join(cmd)}")

    try:
        result = subprocess.run(
            cmd,
            capture_output=True,
            text=True,
            check=False,
            cwd=working_dir,
        )

        # Log stderr if present
        if result.stderr:
            logger.error(f"Pylint stderr: {result.stderr}")

        # Check if there were any errors in the output
        has_errors = _has_errors_in_output(result.stdout, output_format)

        # Any non-zero return code from pylint should fail the run
        # https://pylint.pycqa.org/en/latest/user_guide/usage/run.html#exit-codes
        exit_code = 1 if (has_errors or result.returncode != 0) else 0
        return exit_code, result.stdout

    except subprocess.CalledProcessError as e:
        logger.error(f"Error running pylint: {e!s}")
        return 1, e.output or str(e)
