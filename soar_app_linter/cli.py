"""Command-line interface for soar-app-linter."""
from __future__ import annotations

import argparse
import json
import logging
import os
import subprocess
import sys
from enum import Enum
from pathlib import Path
import re
from enum import Enum
from pathlib import Path
from typing import Any, Union
from packaging.version import Version
import glob

# Set up logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

PYTHON_313_VERSION = Version("3.13")

class NotFoundError(Exception):
    """App JSON not found"""

class MessageLevel(str, Enum):
    ERROR = "error"
    INFO = "info"

    def to_pylint_disable(self) -> list[str]:
        """Convert to pylint's disable arguments."""
        if self == MessageLevel.ERROR:
            return ["--disable=all", "--enable=F,E"]
        return []  # info or no option provided will show everything

def find_python_files(directory: str) -> list[str]:
    """Find all Python files in the given directory."""
    logger.debug(f"Searching for Python files in: {directory}")

    if not os.path.exists(directory):
        logger.error(f"Directory does not exist: {directory}")
        return []

    if not os.path.isdir(directory):
        logger.error(f"Path is not a directory: {directory}")
        return []

    files = []
    for path in Path(directory).rglob("*.py"):
        if path.is_file() and not path.name.startswith('.'):
            logger.debug(f"Found Python file: {path}")
            files.append(str(path))

    logger.debug(f"Found {len(files)} Python files in {directory}")

    # Debug: List all files in directory
    try:
        all_files = list(Path(directory).rglob("*"))
        logger.debug(f"All files in directory ({len(all_files)}): {[str(f) for f in all_files]}")
    except Exception as e:
        logger.error(f"Error listing directory contents: {e}")

    return files

def ensure_init_files(directory: str) -> None:
    """Ensure all Python packages have __init__.py files."""
    logger.debug(f"Ensuring __init__.py files in: {directory}")
    init_created = 0

    for root, dirs, _ in os.walk(directory):
        # Skip hidden directories and __pycache__
        dirs[:] = [d for d in dirs if not d.startswith(".") and d != "__pycache__"]

        # Skip if this is a Python package with an __init__.py
        init_path = os.path.join(root, "__init__.py")
        if os.path.isfile(init_path):
            continue

        # Check if this is a Python package (has .py files or is imported)
        has_py_files = any(fname.endswith('.py') for fname in os.listdir(root))
        is_imported = any(
            os.path.isfile(os.path.join(root, f"{d}.py"))
            for d in os.listdir(os.path.dirname(root) if os.path.dirname(root) != root else root)
            if os.path.isdir(os.path.join(os.path.dirname(root) if os.path.dirname(root) != root else root, d))
        )

        if has_py_files or is_imported:
            # Create empty __init__.py
            with open(init_path, 'w', encoding='utf-8') as f:
                f.write("# Automatically generated by pylint-runner\n")
            logger.debug(f"Created {init_path}")
            init_created += 1

    if init_created > 0:
        logger.debug(f"Created {init_created} __init__.py files")
    else:
        logger.debug("No new __init__.py files were needed")

def parse_args(args: list[str] | None = None) -> argparse.Namespace:
    """Parse command line arguments."""
    parser = argparse.ArgumentParser(
        description="Run pylint with custom rules and automatic __init__.py management"
    )

    parser.add_argument(
        "target",
        help="Directory or file to lint",
        type=str,
    )

    parser.add_argument(
        "--json",
        action="store_true",
        help="Output results in JSON format",
    )

    parser.add_argument(
        "--no-init",
        action="store_true",
        help="Disable automatic creation of __init__.py files",
    )

    parser.add_argument(
        "--verbose",
        action="store_true",
        help="Enable verbose output",
    )

    parser.add_argument(
        "--message-level",
        type=MessageLevel,
        choices=list(MessageLevel),
        default=MessageLevel.INFO,
        help="Minimum message level to show (info, warning, error)",
    )

    parser.add_argument(
        "--version",
        action="version",
        version=f"%(prog)s {__import__('soar_app_linter').__version__}",
    )

    parser.add_argument(
        "--no-deps",
        action="store_true",
        help="Disable automatic installation of dependencies. This also disables import errors from being reported.",
    )

    parser.add_argument(
        "--disable-app-json-validation",
        action="store_true",
        help="Disable validation of app.json file",
    )

    return parser.parse_args(args)

def has_errors_in_output(output: str, output_format: str) -> bool:
    """Check if there are any errors in the pylint output."""
    if output_format == "json":
        try:
            results = json.loads(output)
            return any(
                result.get("type") in ("error", "fatal")
                for result in results
            )
        except json.JSONDecodeError:
            raise
    else:
        # For text output, look for error indicators
        error_pattern = re.compile(r':\s[EF]\d{4}:')
        return any(
            bool(error_pattern.search(line))
            for line in output.splitlines()
        )

def run_pylint(
    target: str,
    output_format: str = "text",
    verbose: bool = False,
    message_level: MessageLevel = MessageLevel.INFO,
    no_deps: bool = False,
) -> tuple[int, str]:
    """Run pylint on the target directory or file.

    Args:
        target: The target directory or file to lint
        output_format: Output format ('text' or 'json')
        verbose: Enable verbose output
        message_level: Minimum message level to show
        no_deps: If True, skip dependency installation and ignore import errors

    Returns:
        tuple: (exit_code, output)
    """
    if verbose:
        logger.setLevel(logging.DEBUG)

    # Install dependencies if not explicitly disabled
    if not no_deps:
        install_dependencies(target)

    logger.debug(f"Running pylint on target: {target}")

    # Create a dynamic init-hook that adds the target directory to Python path
    init_hook = (
        'import sys, os; '
        f'sys.path.extend(["{target}"])'
    )

    cmd = [
        sys.executable,
        "-m",
        "pylint",
        f"--rcfile={os.path.join(os.path.dirname(__file__), 'pylintrc.app')}",
        "--load-plugins=soar_app_linter.plugins",
        f"--init-hook={init_hook}",
    ]

    # Add message level filtering
    disable = message_level.to_pylint_disable()
    if disable:
        cmd.extend(disable)

    # Ignore import errors when no_deps is True
    if no_deps:
        cmd.extend(["--disable=import-error"])

    if output_format == "json":
        cmd.append("--output-format=json")

    if os.path.isdir(target):
        ensure_init_files(target)
        files = find_python_files(target)
        if not files:
            logger.warning(f"No Python files found in {target}")
            return 0, ""
        cmd.extend(files)
    else:
        if not os.path.exists(target):
            logger.error(f"Target file does not exist: {target}")
            return 1, f"Error: Target file does not exist: {target}"
        cmd.append(target)

    logger.debug(f"Running command: {' '.join(cmd)}")
    try:
        result = subprocess.run(
            cmd,
            capture_output=True,
            text=True,
            check=False,
        )

        # Log stderr if present
        if result.stderr:
            logger.error(f"Pylint stderr: {result.stderr}")

        # Check if there were any errors in the output
        has_errors = has_errors_in_output(result.stdout, output_format)

        # Return code is 0 only if there were no errors and pylint succeeded
        # https://pylint.pycqa.org/en/latest/user_guide/usage/run.html#exit-codes
        exit_code = 1 if (has_errors or result.returncode in (1,2)) else 0
        return exit_code, result.stdout

    except subprocess.CalledProcessError as e:
        logger.error(f"Error running pylint: {e!s}")
        return 1, e.output or str(e)

def is_empty_or_irrelevant(file_path: Path) -> bool:
    """Check if a file is empty or doesn't contain any dependencies."""
    if not file_path.exists():
        return True

    if file_path.suffix == '.toml':
        try:
            import tomli
            with open(file_path, 'rb') as f:
                data = tomli.load(f)
            # Check if project.dependencies exists and is not empty
            has_deps = bool(data.get('project', {}).get('dependencies'))
            has_build_system = 'build-system' in data
            # If it has a build system but no deps, it's a package that needs installation
            return not has_deps and not has_build_system
        except Exception:
            # If we can't parse the file, assume it's not empty
            return False
    elif file_path.suffix == '.txt':
        # Check if file is empty or only contains comments/whitespace
        with open(file_path) as f:
            return not any(line.strip() and not line.strip().startswith('#')
                         for line in f)
    return False

def install_dependencies(directory: str) -> bool:
    """Install dependencies using uv if a dependency file is found.

    Supported files (in order of precedence):
    - pyproject.toml (installs in development mode only if it has dependencies)
    - requirements.txt
    - requirements-dev.txt
    - setup.py (installs in development mode)
    - setup.cfg (installs in development mode)

    Args:
        directory: Directory containing the dependency files

    Returns:
        bool: True if installation was successful, no installation was needed,
              or if the file exists but has no dependencies to install.
              False if installation failed for other reasons.
    """
    import subprocess
    from pathlib import Path

    # Convert to Path object and resolve to absolute path
    directory = Path(directory).resolve()

    # Check for uv installation
    try:
        subprocess.run(
            ["uv", "--version"],
            check=True,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE
        )
    except (subprocess.SubprocessError, FileNotFoundError):
        logger.warning(
            "uv is not installed. Please install it with 'pip install uv' "
            "for faster dependency resolution.")
        return False

    # Define supported dependency files in order of precedence
    # For pyproject.toml, we'll handle it specially to check for deps first
    dependency_files = [
        (directory / "requirements.txt", ["uv", "pip", "install", "-r", "requirements.txt"]),
        (directory / "requirements-dev.txt", ["uv", "pip", "install", "-r", "requirements-dev.txt"]),
        (directory / "setup.py", ["uv", "pip", "install", "-e", "."]),
        (directory / "setup.cfg", ["uv", "pip", "install", "-e", "."]),
    ]

    # Check pyproject.toml first if it exists
    pyproject = directory / "pyproject.toml"
    if pyproject.exists():
        if not is_empty_or_irrelevant(pyproject):
            # If it has dependencies, add it to the front of the list
            dependency_files.insert(0, (pyproject, ["uv", "pip", "install", "-e", "."]))

    # Check for requirements/*.txt files
    requirements_dir = directory / "requirements"
    if requirements_dir.is_dir():
        for req_file in requirements_dir.glob("*.txt"):
            if not is_empty_or_irrelevant(req_file):
                dependency_files.insert(1, (
                    req_file,
                    ["uv", "pip", "install", "-r", str(req_file.relative_to(directory))]
                ))

    # Try each dependency file in order
    for dep_file, cmd in dependency_files:
        if dep_file.exists() and not is_empty_or_irrelevant(dep_file):
            logger.info(f"Retrieving dependencies for {dep_file.name}...")
            try:
                result = subprocess.run(
                    cmd,
                    cwd=directory,
                    check=False,  # Don't raise exception on non-zero exit
                    stdout=subprocess.PIPE,
                    stderr=subprocess.PIPE,
                    text=True
                )

                if result.returncode == 0:
                    logger.info("Dependencies installed successfully")
                    return True
                else:
                    # Check if the error is due to no dependencies to install
                    if any(msg in (result.stderr or "") for msg in
                          ["No dependencies to install",
                           "No matching distribution",
                           "does not appear to be a Python project"]):
                        logger.debug(f"No dependencies to install from {dep_file.name}")
                        return True

                    logger.error(
                        f"Failed to install dependencies from {dep_file.name}. "
                        f"Error: {result.stderr.strip() or result.stdout.strip()}"
                    )
                    return False

            except Exception as e:
                logger.error(f"Unexpected error installing dependencies from {dep_file.name}: {e}")
                return False

    logger.debug("No supported non-empty dependency files found, skipping dependency installation")
    return True

# TODO is this a list that could be aqcuired via the splunk-soar-sdk?
REQUIRED_APP_JSON_FIELDS = (
    "appid",
    "name",
    "description",
    "publisher",
    "package_name",
    "type",
    "main_module",
    "app_version",
    "product_vendor",
    "product_name",
    "product_version_regex",
    "min_phantom_version",
    "logo",
    "configuration",
    "actions",
    "python_version",
)

def _find_app_json(
    app_dir: Union[str, os.PathLike]) -> tuple[str, dict[str, Any]]:
    """
    Locate and return an app's json file
    If given an app directory, search for the app's json file and return its path and contents.
    If given an app tarball, without extracting the entire tarball, find the app's json file and returns its path within the tarball and contents
    We have to search since there's no set naming convention for the file, and apps can have more than one
    file with the json extension in their directories
    """
    errors = []
    required_fields = REQUIRED_APP_JSON_FIELDS

    json_filepaths = glob.glob(os.path.join(app_dir, "*.json"))
    
    if not json_filepaths:
        raise NotFoundError(f'No JSON files found in directory "{app_dir}"')

    for json_filepath in json_filepaths:
        try:
            with open(json_filepath) as f:
                json_content = json.load(f)
            if not isinstance(json_content, dict):
                errors.append(f"{json_filepath}: Expected a JSON object")
                continue
                
            missing = [field for field in required_fields if field not in json_content]
            if missing:
                errors.append(f"{json_filepath}: Missing required fields: {', '.join(missing)}")
                continue
                
            return json_filepath, json_content
            
        except (OSError, ValueError, json.JSONDecodeError) as e:
            errors.append(f"{json_filepath}: {str(e)}")
            continue

    # If we get here, no valid app.json was found
    error_msg = (
        f'No suitable app JSON found in directory "{app_dir}".\n'
        'Encountered the following errors while searching:\n'
    )
    error_msg += '\n'.join(f"  - {error}" for error in errors)
    raise ValueError(error_msg)

def _app_python_versions(app_json: [dict[str, Any]] = None) -> set[Version]:
    if app_json is None:
        raise ValueError(
            "'app_json' must be defined to determine python versions"
        )

    assert app_json is not None  # this appeases typecheckers

    python_versions = app_json.get("python_version")
    if not python_versions:
        raise ValueError("'python_version' must be defined in app json")
    elif isinstance(python_versions, (float, int)):
        python_versions = [python_versions]
    elif isinstance(python_versions, str):
        python_versions = python_versions.split(",")
    elif not isinstance(python_versions, list):
        raise ValueError("'python_version' must be a list, string, float or int")

    out: set[Version] = set()
    for python_version in python_versions:
        if not (python_version := str(python_version).strip()):
            # skip empty strings
            continue

        # only take major(.minor)?
        if match := re.match(r"^\d+(\.\d+)?", python_version):
            python_version = match[0]

        # replace any instances of "3" with "3.9" for clarity
        if python_version == Version("3"):
            python_version = Version("3.9")

        out.add(Version(python_version))

    return out

def find_and_validate_app_json(target_dir: str) -> bool:
    """Validate that the app_json contains a valid python_version that includes PYTHON_313_VERSION.
    
    Args:
        app_json: The parsed app.json content as a dictionary
        
    Returns:
        bool: True if validation passes, False otherwise
    """
    app_json_path, app_json = _find_app_json(target_dir)
    try:
        python_versions = _app_python_versions(app_json)
        if PYTHON_313_VERSION not in python_versions:
            logger.error(f"App does not list SOAR supported Python {PYTHON_313_VERSION} versions in the `python_version` field of the app json {app_json_path}")
            return False
        return True
    except ValueError as e:
        logger.error(str(e))
        breakpoint()
        raise

def main() -> int:
    """Main entry point for the CLI."""
    args = parse_args()

    if not os.path.exists(args.target):
        logger.error(f"Error: Target '{args.target}' does not exist")
        return 1

    if not args.disable_app_json_validation:
        if not find_and_validate_app_json(args.target):
            return 1

    if not args.no_init and os.path.isdir(args.target):
        ensure_init_files(args.target)

    output_format = "json" if args.json else "text"
    exit_code, output = run_pylint(
        args.target,
        output_format=output_format,
        verbose=args.verbose,
        message_level=args.message_level,
        no_deps=args.no_deps,
    )

    if output:
        print(output, end="")

    return exit_code

if __name__ == "__main__":
    sys.exit(main())
